# 33. Search in Rotated Sorted Array

#### æ¯å¤©æ‘¸é±¼ä¸€æ®µä»£ç ï¼Œä»Šå¤©æ˜¯ **2022å¹´12æœˆ5æ—¥**ï¼Œç¬¬12å¤©

#### è¯¦æƒ…ï¼šwuff.garafox.com 

## é—®é¢˜

There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the possible rotation and an integer `target`, return *the index of* `target` *if it is in* `nums`*, or* `-1` *if it is not in* `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

## ä»£ç 

```c
int search(int* nums, int numsSize, int target){
    for(int i = 0; i < numsSize; i++){
        if(nums[i] == target){
            return i;
        }
    }
    return -1;
}
```

## è¿è¡Œ

*Success*

Runtime: 3 ms, faster than 82.87% of C online submissions for Search in Rotated Sorted Array.

Memory Usage: 6.3 MB, less than 5.27% of C online submissions for Search in Rotated Sorted Array.

## æ€»ç»“

Things shouldn't be like this... ğŸ˜…

